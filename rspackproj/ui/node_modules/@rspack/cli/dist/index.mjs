import * as __WEBPACK_EXTERNAL_MODULE__rspack_core__ from "@rspack/core";
import * as __WEBPACK_EXTERNAL_MODULE_node_fs__ from "node:fs";
import * as __WEBPACK_EXTERNAL_MODULE_node_inspector__ from "node:inspector";
import * as __WEBPACK_EXTERNAL_MODULE_node_path__ from "node:path";
import * as __WEBPACK_EXTERNAL_MODULE_node_url__ from "node:url";
import * as __WEBPACK_EXTERNAL_MODULE_node_util__ from "node:util";
import * as __WEBPACK_EXTERNAL_MODULE_colorette__ from "colorette";
import * as __WEBPACK_EXTERNAL_MODULE_semver__ from "semver";
import * as __WEBPACK_EXTERNAL_MODULE_yargs__ from "yargs";
import * as __WEBPACK_EXTERNAL_MODULE_yargs_helpers__ from "yargs/helpers";
import * as __WEBPACK_EXTERNAL_MODULE_interpret__ from "interpret";
import * as __WEBPACK_EXTERNAL_MODULE_rechoir__ from "rechoir";
var __webpack_modules__ = {
    "./src/utils/crossImport.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        __webpack_require__.d(__webpack_exports__, {
            Z: function() {
                return __WEBPACK_DEFAULT_EXPORT__;
            },
            y: function() {
                return dynamicImport;
            }
        });
        /* ESM import */ var node_url__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__("node:url");
        /* ESM import */ var _isEsmFile__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__("./src/utils/isEsmFile.ts");
        /**
 * Dynamically import files. It will make sure it's not being compiled away by TS/Rslib.
 */ const dynamicImport = new Function("path", "return import(path)");
        const crossImport = async (path, cwd = process.cwd())=>{
            if ((0, _isEsmFile__WEBPACK_IMPORTED_MODULE_1__ /* ["default"] */ .Z)(path, cwd)) {
                const url = (0, node_url__WEBPACK_IMPORTED_MODULE_0__.pathToFileURL)(path).href;
                const { default: config } = await dynamicImport(url);
                return config;
            }
            let result = require(path);
            // compatible with export default config in common ts config
            if (result && "object" == typeof result && "default" in result) result = result.default || {};
            return result;
        };
        /* ESM default export */ const __WEBPACK_DEFAULT_EXPORT__ = crossImport;
    },
    "./src/utils/isEsmFile.ts": function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {
        // EXPORTS
        __webpack_require__.d(__webpack_exports__, {
            Z: ()=>/* binding */ isEsmFile
        });
        // EXTERNAL MODULE: external "node:path"
        var external_node_path_ = __webpack_require__("node:path");
        // EXTERNAL MODULE: external "node:fs"
        var external_node_fs_ = __webpack_require__("node:fs");
        const readPackageUp_readPackageUp = (cwd = process.cwd())=>{
            let currentDir = external_node_path_["default"].resolve(cwd);
            let packageJsonPath = external_node_path_["default"].join(currentDir, "package.json");
            while(!external_node_fs_["default"].existsSync(packageJsonPath)){
                const parentDir = external_node_path_["default"].dirname(currentDir);
                if (parentDir === currentDir) return null;
                currentDir = parentDir;
                packageJsonPath = external_node_path_["default"].join(currentDir, "package.json");
            }
            try {
                return JSON.parse(external_node_fs_["default"].readFileSync(packageJsonPath, "utf8"));
            } catch (error) {
                return null;
            }
        };
        /* ESM default export */ const readPackageUp = readPackageUp_readPackageUp;
        const isEsmFile_isEsmFile = (filePath, cwd = process.cwd())=>{
            const ext = external_node_path_["default"].extname(filePath);
            if (/\.(mjs|mts)$/.test(ext)) return true;
            if (/\.(cjs|cts)/.test(ext)) return false;
            const packageJson = readPackageUp(cwd);
            return (null == packageJson ? void 0 : packageJson.type) === "module";
        };
        /* ESM default export */ const isEsmFile = isEsmFile_isEsmFile;
    },
    "@rspack/core": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE__rspack_core__;
    },
    "node:fs": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_fs__;
    },
    "node:inspector": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_inspector__;
    },
    "node:path": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_path__;
    },
    "node:url": function(module) {
        module.exports = __WEBPACK_EXTERNAL_MODULE_node_url__;
    }
};
/************************************************************************/ // The module cache
var __webpack_module_cache__ = {};
// The require function
function __webpack_require__(moduleId) {
    // Check if module is in cache
    var cachedModule = __webpack_module_cache__[moduleId];
    if (void 0 !== cachedModule) return cachedModule.exports;
    // Create a new module (and put it into the cache)
    var module = __webpack_module_cache__[moduleId] = {
        exports: {}
    };
    // Execute the module function
    __webpack_modules__[moduleId](module, module.exports, __webpack_require__);
    // Return the exports of the module
    return module.exports;
}
// expose the modules object (__webpack_modules__)
__webpack_require__.m = __webpack_modules__;
/************************************************************************/ // webpack/runtime/define_property_getters
(()=>{
    __webpack_require__.d = function(exports, definition) {
        for(var key in definition)if (__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) Object.defineProperty(exports, key, {
            enumerable: true,
            get: definition[key]
        });
    };
})();
// webpack/runtime/ensure_chunk
(()=>{
    __webpack_require__.f = {};
    // This file contains only the entry chunk.
    // The chunk loading function for additional chunks
    __webpack_require__.e = function(chunkId) {
        return Promise.all(Object.keys(__webpack_require__.f).reduce(function(promises, key) {
            __webpack_require__.f[key](chunkId, promises);
            return promises;
        }, []));
    };
})();
// webpack/runtime/get javascript chunk filename
(()=>{
    // This function allow to reference chunks
    __webpack_require__.u = function(chunkId) {
        // return url for filenames not based on template
        // return url for filenames based on template
        return "" + chunkId + ".mjs";
    };
})();
// webpack/runtime/has_own_property
(()=>{
    __webpack_require__.o = function(obj, prop) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };
})();
// webpack/runtime/module_chunk_loading
(()=>{
    // object to store loaded and loading chunks
    // undefined = chunk not loaded, null = chunk preloaded/prefetched
    // [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
    var installedChunks = {
        980: 0
    };
    var installChunk = function(data) {
        var ids = data.ids;
        var modules = data.modules;
        var runtime = data.runtime;
        // add "modules" to the modules object,
        // then flag all "ids" as loaded and fire callback
        var moduleId, chunkId, i = 0;
        for(moduleId in modules)if (__webpack_require__.o(modules, moduleId)) __webpack_require__.m[moduleId] = modules[moduleId];
        if (runtime) runtime(__webpack_require__);
        for(; i < ids.length; i++){
            chunkId = ids[i];
            if (__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) installedChunks[chunkId][0]();
            installedChunks[ids[i]] = 0;
        }
    };
    __webpack_require__.f.j = function(chunkId, promises) {
        // import() chunk loading for javascript
        var installedChunkData = __webpack_require__.o(installedChunks, chunkId) ? installedChunks[chunkId] : void 0;
        if (0 !== installedChunkData) {
            // a Promise means "currently loading".
            if (installedChunkData) promises.push(installedChunkData[1]);
            else {
                // setup Promise in chunk cache
                var promise = import("./" + __webpack_require__.u(chunkId)).then(installChunk, function(e) {
                    if (0 !== installedChunks[chunkId]) installedChunks[chunkId] = void 0;
                    throw e;
                });
                var promise = Promise.race([
                    promise,
                    new Promise(function(resolve) {
                        installedChunkData = installedChunks[chunkId] = [
                            resolve
                        ];
                    })
                ]);
                promises.push(installedChunkData[1] = promise);
            }
        }
    };
})();
// EXTERNAL MODULE: external "node:path"
var external_node_path_ = __webpack_require__("node:path");
// EXTERNAL MODULE: external "@rspack/core"
var core_ = __webpack_require__("@rspack/core");
// EXTERNAL MODULE: external "node:fs"
var external_node_fs_ = __webpack_require__("node:fs");
const commonOptions = (yargs)=>yargs.options({
        config: {
            g: true,
            type: "string",
            describe: "config file",
            alias: "c"
        },
        entry: {
            type: "array",
            string: true,
            describe: "entry file"
        },
        "output-path": {
            type: "string",
            describe: "output path dir",
            alias: "o"
        },
        mode: {
            type: "string",
            describe: "mode",
            alias: "m"
        },
        watch: {
            type: "boolean",
            default: false,
            describe: "watch",
            alias: "w"
        },
        env: {
            type: "array",
            string: true,
            describe: "env passed to config function"
        },
        "node-env": {
            string: true,
            describe: "sets process.env.NODE_ENV to be specified value"
        },
        devtool: {
            type: "boolean",
            default: false,
            describe: "devtool",
            alias: "d"
        },
        configName: {
            type: "array",
            string: true,
            describe: "Name of the configuration to use."
        }
    }).alias({
        v: "version",
        h: "help"
    });
const previewOptions = (yargs)=>yargs.positional("dir", {
        type: "string",
        describe: "directory want to preview"
    }).options({
        publicPath: {
            type: "string",
            describe: "static resource server path"
        },
        config: {
            g: true,
            type: "string",
            describe: "config file",
            alias: "c"
        },
        port: {
            type: "number",
            describe: "preview server port"
        },
        host: {
            type: "string",
            describe: "preview server host"
        },
        open: {
            type: "boolean",
            describe: "open browser"
        },
        // same as devServer.server
        server: {
            type: "string",
            describe: "Configuration items for the server."
        },
        configName: {
            type: "array",
            string: true,
            describe: "Name of the configuration to use."
        }
    });
function normalizeEnv(argv) {
    function parseValue(previous, value) {
        const [allKeys, val] = value.split(/=(.+)/, 2);
        const splitKeys = allKeys.split(/\.(?!$)/);
        let prevRef = previous;
        splitKeys.forEach((key, index)=>{
            let someKey = key;
            // https://github.com/webpack/webpack-cli/issues/3284
            if (someKey.endsWith("=")) {
                // remove '=' from key
                someKey = someKey.slice(0, -1);
                prevRef[someKey] = void 0;
                return;
            }
            if (!prevRef[someKey] || "string" == typeof prevRef[someKey]) prevRef[someKey] = {};
            if (index === splitKeys.length - 1) {
                if ("string" == typeof val) prevRef[someKey] = val;
                else prevRef[someKey] = true;
            }
            prevRef = prevRef[someKey];
        });
        return previous;
    }
    const envObj = (argv.env ?? []).reduce(parseValue, {});
    argv.env = envObj;
}
/**
 * set builtin env from cli - like `WEBPACK_BUNDLE=true`. also for `RSPACK_` prefixed.
 * @param env the `argv.env` object
 * @param envNameSuffix the added env will be `WEBPACK_${envNameSuffix}` and `RSPACK_${envNameSuffix}`
 * @param value
 */ function setBuiltinEnvArg(env, envNameSuffix, value) {
    const envNames = [
        // TODO: breaking change
        // `WEBPACK_${envNameSuffix}`,
        `RSPACK_${envNameSuffix}`
    ];
    for (const envName of envNames){
        if (!(envName in env)) env[envName] = value;
    }
}
/**
 * infer `argv.env` as an object for it was transformed from array to object after `normalizeEnv` middleware
 * @returns the reference of `argv.env` object
 */ function ensureEnvObject(options) {
    if (Array.isArray(options.env)) // in case that cli haven't got `normalizeEnv` middleware applied
    normalizeEnv(options);
    options.env = options.env || {};
    return options.env;
}
class BuildCommand {
    async apply(cli) {
        cli.program.command([
            "build",
            "$0",
            "bundle",
            "b"
        ], "run the rspack build", (yargs)=>commonOptions(yargs).options({
                analyze: {
                    type: "boolean",
                    default: false,
                    describe: "analyze"
                },
                json: {
                    describe: "emit stats json"
                },
                profile: {
                    type: "boolean",
                    default: false,
                    describe: "capture timing information for each module"
                }
            }), async (options)=>{
            const env = ensureEnvObject(options);
            if (options.watch) setBuiltinEnvArg(env, "WATCH", true);
            else {
                setBuiltinEnvArg(env, "BUNDLE", true);
                setBuiltinEnvArg(env, "BUILD", true);
            }
            const logger = cli.getLogger();
            let createJsonStringifyStream;
            if (options.json) {
                const jsonExt = await import("@discoveryjs/json-ext");
                createJsonStringifyStream = jsonExt.default.stringifyStream;
            }
            const errorHandler = (error, stats)=>{
                if (error) {
                    logger.error(error);
                    process.exit(2);
                }
                if (null == stats ? void 0 : stats.hasErrors()) process.exitCode = 1;
                if (!compiler || !stats) return;
                const statsOptions = cli.isMultipleCompiler(compiler) ? {
                    children: compiler.compilers.map((compiler)=>compiler.options ? compiler.options.stats : void 0)
                } : compiler.options ? compiler.options.stats : void 0;
                if (options.json && createJsonStringifyStream) {
                    const handleWriteError = (error)=>{
                        logger.error(error);
                        process.exit(2);
                    };
                    if (true === options.json) createJsonStringifyStream(stats.toJson(statsOptions)).on("error", handleWriteError).pipe(process.stdout).on("error", handleWriteError).on("close", ()=>process.stdout.write("\n"));
                    else if ("string" == typeof options.json) createJsonStringifyStream(stats.toJson(statsOptions)).on("error", handleWriteError).pipe(external_node_fs_.createWriteStream(options.json)).on("error", handleWriteError) // Use stderr to logging
                    .on("close", ()=>{
                        process.stderr.write(`[rspack-cli] ${cli.colors.green(`stats are successfully stored as json to ${options.json}`)}\n`);
                    });
                } else {
                    const printedStats = stats.toString(statsOptions);
                    // Avoid extra empty line when `stats: 'none'`
                    if (printedStats) logger.raw(printedStats);
                }
            };
            const rspackOptions = {
                ...options,
                argv: {
                    ...options
                }
            };
            const compiler = await cli.createCompiler(rspackOptions, "build", errorHandler);
            if (!compiler || cli.isWatch(compiler)) return;
            compiler.run((error, stats)=>{
                // If there is a compilation error, the close method should not be called,
                // Otherwise Rspack may generate invalid caches.
                if (error || (null == stats ? void 0 : stats.hasErrors())) errorHandler(error, stats);
                else compiler.close((closeErr)=>{
                    if (closeErr) logger.error(closeErr);
                    errorHandler(error, stats);
                });
            });
        });
    }
}
const defaultRoot = "dist";
class PreviewCommand {
    async apply(cli) {
        cli.program.command([
            "preview [dir]",
            "preview",
            "p"
        ], "run the rspack server for build output", previewOptions, async (options)=>{
            // configã€configName are necessary for loadConfig
            const rspackOptions = {
                config: options.config,
                configName: options.configName,
                argv: {
                    ...options
                }
            };
            const { RspackDevServer } = await import("@rspack/dev-server");
            let config = await cli.loadConfig(rspackOptions);
            config = await getPreviewConfig(config, options);
            if (!Array.isArray(config)) config = [
                config
            ];
            // find the possible devServer config
            config = config.find((item)=>item.devServer) || config[0];
            const devServerOptions = config.devServer;
            try {
                const compiler = (0, core_.rspack)({
                    entry: {}
                });
                if (!compiler) return;
                const server = new RspackDevServer(devServerOptions, compiler);
                await server.start();
            } catch (error) {
                const logger = cli.getLogger();
                logger.error(error);
                process.exit(2);
            }
        });
    }
}
// get the devServerOptions from the config
async function getPreviewConfig(item, options) {
    const internalPreviewConfig = async (item)=>{
        var _item_output, _item_devServer, _item_devServer1, _item_devServer2, _item_devServer3, _item_devServer4;
        // all of the options that a preview static server needs(maybe not all)
        item.devServer = {
            static: {
                directory: options.dir ? external_node_path_["default"].join(item.context ?? process.cwd(), options.dir) : (null === (_item_output = item.output) || void 0 === _item_output ? void 0 : _item_output.path) ?? external_node_path_["default"].join(item.context ?? process.cwd(), defaultRoot),
                publicPath: options.publicPath ?? "/"
            },
            port: options.port ?? 8080,
            proxy: null === (_item_devServer = item.devServer) || void 0 === _item_devServer ? void 0 : _item_devServer.proxy,
            host: options.host ?? (null === (_item_devServer1 = item.devServer) || void 0 === _item_devServer1 ? void 0 : _item_devServer1.host),
            open: options.open ?? (null === (_item_devServer2 = item.devServer) || void 0 === _item_devServer2 ? void 0 : _item_devServer2.open),
            server: options.server ?? (null === (_item_devServer3 = item.devServer) || void 0 === _item_devServer3 ? void 0 : _item_devServer3.server),
            historyApiFallback: null === (_item_devServer4 = item.devServer) || void 0 === _item_devServer4 ? void 0 : _item_devServer4.historyApiFallback
        };
        return item;
    };
    if (Array.isArray(item)) return Promise.all(item.map(internalPreviewConfig));
    return internalPreviewConfig(item);
}
class ServeCommand {
    async apply(cli) {
        cli.program.command([
            "serve",
            "server",
            "s",
            "dev"
        ], "run the rspack dev server.", (yargs)=>commonOptions(yargs).options({
                hot: {
                    coerce: (arg)=>{
                        if ("boolean" == typeof arg || "only" === arg) return arg;
                        if ("false" === arg) return false;
                        return true;
                    },
                    describe: "enables hot module replacement"
                },
                port: {
                    type: "number",
                    coerce: (arg)=>Number.isInteger(arg) ? arg : void 0,
                    describe: "allows to specify a port to use"
                },
                host: {
                    type: "string",
                    describe: "allows to specify a hostname to use"
                }
            }), async (options)=>{
            setBuiltinEnvArg(ensureEnvObject(options), "SERVE", true);
            const rspackOptions = {
                ...options,
                argv: {
                    ...options
                }
            };
            /**
				 * webpack-dev-server will set `process.env.WEBPACK_SERVE` to true
				 * when its module is imported, so we have to lazy load the package
				 * to make sure the envvar is not set on build mode.
				 * when run in serve mode, we have to load the package before config
				 * module is imported so that the envvar `process.env.WEBPACK_SERVE`
				 * got in config module could be `true`.
				 * related issue: https://github.com/web-infra-dev/rspack/issues/6359
				 */ const { RspackDevServer } = await import("@rspack/dev-server");
            const compiler = await cli.createCompiler(rspackOptions, "serve");
            if (!compiler) return;
            const compilers = cli.isMultipleCompiler(compiler) ? compiler.compilers : [
                compiler
            ];
            const possibleCompilers = compilers.filter((compiler)=>compiler.options.devServer);
            const usedPorts = [];
            const servers = [];
            /**
				 * Webpack uses an Array of compilerForDevServer,
				 * however according to it's doc https://webpack.js.org/configuration/dev-server/#devserverhot
				 * It should use only the first one
				 *
				 * Choose the one for configure devServer
				 */ const compilerForDevServer = possibleCompilers.length > 0 ? possibleCompilers[0] : compilers[0];
            /**
				 * Rspack relies on devServer.hot to enable HMR
				 */ for (const compiler of compilers){
                const devServer = compiler.options.devServer ??= {};
                devServer.hot = options.hot ?? devServer.hot ?? true;
                if (false !== devServer.client) {
                    if (true === devServer.client || null == devServer.client) devServer.client = {};
                    devServer.client = {
                        overlay: {
                            errors: true,
                            warnings: false
                        },
                        ...devServer.client
                    };
                }
            }
            const result = compilerForDevServer.options.devServer ??= {};
            /**
				 * Enable this to tell Rspack that we need to enable React Refresh by default
				 */ result.hot = options.hot ?? result.hot ?? true;
            result.host = options.host || result.host;
            result.port = options.port || result.port;
            if (false !== result.client) {
                if (true === result.client || null == result.client) result.client = {};
                result.client = {
                    overlay: {
                        errors: true,
                        warnings: false
                    },
                    ...result.client
                };
            }
            const devServerOptions = result;
            if (devServerOptions.port) {
                const portNumber = Number(devServerOptions.port);
                if (!Number.isNaN(portNumber)) {
                    if (usedPorts.find((port)=>portNumber === port)) throw new Error("Unique ports must be specified for each devServer option in your rspack configuration. Alternatively, run only 1 devServer config using the --config-name flag to specify your desired config.");
                    usedPorts.push(portNumber);
                }
            }
            try {
                const server = new RspackDevServer(devServerOptions, compiler);
                await server.start();
                servers.push(server);
            } catch (error) {
                const logger = cli.getLogger();
                logger.error(error);
                process.exit(2);
            }
        });
    }
}
// EXTERNAL MODULE: ./src/utils/crossImport.ts
var crossImport = __webpack_require__("./src/utils/crossImport.ts");
const DEFAULT_EXTENSIONS = [
    ".js",
    ".ts",
    ".mjs",
    ".mts",
    ".cjs",
    ".cts"
];
/**
 * Takes a basePath like `webpack.config`, return `webpack.config.{ext}` if
 * exists. returns undefined if none of them exists
 */ const findConfig = (basePath)=>DEFAULT_EXTENSIONS.map((ext)=>basePath + ext).find(external_node_fs_["default"].existsSync);
/* ESM default export */ const utils_findConfig = findConfig;
// EXTERNAL MODULE: ./src/utils/isEsmFile.ts + 1 modules
var isEsmFile = __webpack_require__("./src/utils/isEsmFile.ts");
const isTsFile = (configPath)=>{
    const ext = external_node_path_["default"].extname(configPath);
    return /\.(c|m)?ts$/.test(ext);
};
/* ESM default export */ const utils_isTsFile = isTsFile;
const loadConfig_DEFAULT_CONFIG_NAME = "rspack.config";
const registerLoader = (configPath)=>{
    const ext = external_node_path_["default"].extname(configPath);
    // TODO implement good `.mts` support after https://github.com/gulpjs/rechoir/issues/43
    // For ESM and `.mts` you need to use: 'NODE_OPTIONS="--loader ts-node/esm" rspack build --config ./rspack.config.mts'
    if ((0, isEsmFile /* default */ .Z)(configPath) && utils_isTsFile(configPath)) return;
    const extensions = Object.fromEntries(Object.entries(__WEBPACK_EXTERNAL_MODULE_interpret__["default"].extensions).filter(([key])=>key === ext));
    if (0 === Object.keys(extensions).length) throw new Error(`config file "${configPath}" is not supported.`);
    try {
        __WEBPACK_EXTERNAL_MODULE_rechoir__["default"].prepare(extensions, configPath);
    } catch (error) {
        const failures = null == error ? void 0 : error.failures;
        if (failures) {
            const messages = failures.map((failure)=>failure.error.message);
            throw new Error(`${messages.join("\n")}`);
        }
        throw error;
    }
};
async function loadRspackConfig(options, cwd = process.cwd()) {
    if (options.config) {
        const configPath = external_node_path_["default"].resolve(cwd, options.config);
        if (!external_node_fs_["default"].existsSync(configPath)) throw new Error(`config file "${configPath}" not found.`);
        utils_isTsFile(configPath) && registerLoader(configPath);
        return (0, crossImport /* default */ .Z)(configPath, cwd);
    }
    const defaultConfig = utils_findConfig(external_node_path_["default"].resolve(cwd, loadConfig_DEFAULT_CONFIG_NAME));
    if (defaultConfig) {
        utils_isTsFile(defaultConfig) && registerLoader(defaultConfig);
        return (0, crossImport /* default */ .Z)(defaultConfig, cwd);
    }
    return {};
}
function _define_property(obj, key, value) {
    if (key in obj) Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
    });
    else obj[key] = value;
    return obj;
}
class RspackCLI {
    async createCompiler(options, rspackCommand, callback) {
        var _process_env, _process;
        process.env.RSPACK_CONFIG_VALIDATE ??= "loose";
        process.env.WATCHPACK_WATCHER_LIMIT = process.env.WATCHPACK_WATCHER_LIMIT || "20";
        const nodeEnv = null === (_process = process) || void 0 === _process ? void 0 : null === (_process_env = _process.env) || void 0 === _process_env ? void 0 : _process_env.NODE_ENV;
        const rspackCommandDefaultEnv = "build" === rspackCommand ? "production" : "development";
        if ("string" == typeof options.nodeEnv) process.env.NODE_ENV = nodeEnv || options.nodeEnv;
        else process.env.NODE_ENV = nodeEnv || rspackCommandDefaultEnv;
        let config = await this.loadConfig(options);
        config = await this.buildConfig(config, options, rspackCommand);
        const isWatch = Array.isArray(config) ? config.some((i)=>i.watch) : config.watch;
        let compiler;
        try {
            compiler = (0, core_.rspack)(config, isWatch ? callback : void 0);
        } catch (e) {
            // Aligned with webpack-cli
            // See: https://github.com/webpack/webpack-cli/blob/eea6adf7d34dfbfd3b5b784ece4a4664834f5a6a/packages/webpack-cli/src/webpack-cli.ts#L2394
            if (e instanceof core_.ValidationError) {
                this.getLogger().error(e.message);
                process.exit(2);
            } else if (e instanceof Error) {
                if ("function" == typeof callback) callback(e);
                else this.getLogger().error(e);
                return null;
            }
            throw e;
        }
        return compiler;
    }
    createColors(useColor) {
        const shouldUseColor = useColor || __WEBPACK_EXTERNAL_MODULE_colorette__.isColorSupported;
        return {
            ...(0, __WEBPACK_EXTERNAL_MODULE_colorette__.createColors)({
                useColor: shouldUseColor
            }),
            isColorSupported: shouldUseColor
        };
    }
    getLogger() {
        return {
            error: (val)=>console.error(`[rspack-cli] ${this.colors.red(__WEBPACK_EXTERNAL_MODULE_node_util__["default"].format(val))}`),
            warn: (val)=>console.warn(`[rspack-cli] ${this.colors.yellow(val)}`),
            info: (val)=>console.info(`[rspack-cli] ${this.colors.cyan(val)}`),
            success: (val)=>console.log(`[rspack-cli] ${this.colors.green(val)}`),
            log: (val)=>console.log(`[rspack-cli] ${val}`),
            raw: (val)=>console.log(val)
        };
    }
    async run(argv) {
        if (__WEBPACK_EXTERNAL_MODULE_semver__["default"].lt(__WEBPACK_EXTERNAL_MODULE_semver__["default"].clean(process.version), "14.0.0")) this.getLogger().warn(`Minimum recommended Node.js version is 14.0.0, current version is ${process.version}`);
        this.program.showHelpOnFail(false);
        this.program.usage("[options]");
        this.program.scriptName("rspack");
        this.program.strictCommands(true).strict(true);
        this.program.middleware(normalizeEnv);
        this.registerCommands();
        await this.program.parseAsync((0, __WEBPACK_EXTERNAL_MODULE_yargs_helpers__.hideBin)(argv));
    }
    async registerCommands() {
        const builtinCommands = [
            new BuildCommand(),
            new ServeCommand(),
            new PreviewCommand()
        ];
        for (const command of builtinCommands)command.apply(this);
    }
    async buildConfig(item, options, command) {
        const isBuild = "build" === command;
        const isServe = "serve" === command;
        const commandDefaultEnv = isBuild ? "production" : "development";
        const internalBuildConfig = async (item)=>{
            if (options.entry) item.entry = {
                main: options.entry.map((x)=>external_node_path_["default"].resolve(process.cwd(), x))[0] // Fix me when entry supports array
            };
            // to set output.path
            item.output = item.output || {};
            if (options["output-path"]) item.output.path = external_node_path_["default"].resolve(process.cwd(), options["output-path"]);
            if (options.analyze) {
                const { BundleAnalyzerPlugin } = await import("webpack-bundle-analyzer");
                (item.plugins ??= []).push({
                    name: "rspack-bundle-analyzer",
                    apply (compiler) {
                        new BundleAnalyzerPlugin({
                            generateStatsFile: true
                        }).apply(compiler);
                    }
                });
            }
            if (options.profile) item.profile = true;
            if (process.env.RSPACK_PROFILE) {
                const { applyProfile } = await __webpack_require__.e(/* import() */ "629").then(__webpack_require__.bind(__webpack_require__, "./src/utils/profile.ts"));
                await applyProfile(process.env.RSPACK_PROFILE, item);
            }
            // cli --watch overrides the watch config
            if (options.watch) item.watch = options.watch;
            // auto set default mode if user config don't set it
            if (!item.mode) item.mode = commandDefaultEnv ?? "none";
            // user parameters always has highest priority than default mode and config mode
            if (options.mode) item.mode = options.mode;
            // false is also a valid value for sourcemap, so don't override it
            if (void 0 === item.devtool) item.devtool = isBuild ? "source-map" : "cheap-module-source-map";
            if (isServe) {
                const installed = (item.plugins ||= []).find((item)=>item instanceof core_.ProgressPlugin);
                if (!installed) (item.plugins ??= []).push(new core_.ProgressPlugin());
            }
            if (void 0 === item.stats) item.stats = {
                preset: "errors-warnings",
                timings: true
            };
            else if ("boolean" == typeof item.stats) item.stats = item.stats ? {
                preset: "normal"
            } : {
                preset: "none"
            };
            else if ("string" == typeof item.stats) item.stats = {
                preset: item.stats
            };
            if (this.colors.isColorSupported && void 0 === item.stats.colors) item.stats.colors = true;
            return item;
        };
        if (Array.isArray(item)) return Promise.all(item.map(internalBuildConfig));
        return internalBuildConfig(item);
    }
    async loadConfig(options) {
        let loadedConfig = await loadRspackConfig(options);
        if ("function" == typeof loadedConfig) {
            var _options_argv;
            loadedConfig = loadedConfig(null === (_options_argv = options.argv) || void 0 === _options_argv ? void 0 : _options_argv.env, options.argv);
            // if return promise we should await its result
            if ("function" == typeof loadedConfig.then) loadedConfig = await loadedConfig;
        }
        if (options.configName) {
            const notFoundConfigNames = [];
            loadedConfig = options.configName.map((configName)=>{
                let found;
                found = Array.isArray(loadedConfig) ? loadedConfig.find((options)=>options.name === configName) : loadedConfig.name === configName ? loadedConfig : void 0;
                if (!found) notFoundConfigNames.push(configName);
                // WARNING: if config is not found, the program will exit
                // so assert here is okay to avoid runtime filtering
                return found;
            });
            if (notFoundConfigNames.length > 0) {
                this.getLogger().error(notFoundConfigNames.map((configName)=>`Configuration with the name "${configName}" was not found.`).join(" "));
                process.exit(2);
            }
        }
        return loadedConfig;
    }
    isMultipleCompiler(compiler) {
        return Boolean(compiler.compilers);
    }
    isWatch(compiler) {
        return Boolean(this.isMultipleCompiler(compiler) ? compiler.compilers.some((compiler)=>compiler.options.watch) : compiler.options.watch);
    }
    constructor(){
        _define_property(this, "colors", void 0);
        _define_property(this, "program", void 0);
        this.colors = this.createColors();
        this.program = (0, __WEBPACK_EXTERNAL_MODULE_yargs__["default"])();
    }
}
function defineConfig(config) {
    return config;
}
function definePlugin(plugin) {
    return plugin;
}
export { RspackCLI, defineConfig, definePlugin };
